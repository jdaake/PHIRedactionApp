{"ast":null,"code":"import _asyncToGenerator from \"/Users/jordandaake/Desktop/source/PHIRedactionApp/phi-redaction-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { HttpErrorResponse } from '@angular/common/http';\nimport { lastValueFrom } from 'rxjs';\nimport { environment } from '../../environments/environment';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport class FileProcessingService {\n  constructor(http) {\n    this.http = http;\n    this.apiUrl = environment.apiUrl;\n  }\n  processFiles(files) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const formData = new FormData();\n      for (let i = 0; i < files.length; i++) {\n        formData.append('files', files[i]);\n      }\n      try {\n        const response = yield lastValueFrom(_this.http.post(`${_this.apiUrl}/files/process`, formData));\n        return response;\n      } catch (error) {\n        console.error('Error processing files:', error);\n        if (error instanceof HttpErrorResponse) {\n          if (error.status === 0) {\n            throw new Error('Unable to connect to the server. Please ensure the API is running.');\n          } else if (error.status >= 400 && error.status < 500) {\n            throw new Error(error.error?.message || 'Invalid request. Please check your files and try again.');\n          } else if (error.status >= 500) {\n            throw new Error('Server error occurred. Please try again later.');\n          }\n        }\n        throw new Error('An unexpected error occurred while processing files.');\n      }\n    })();\n  }\n  downloadFile(downloadUrl, fileName) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        console.log('Downloading file:', downloadUrl);\n        // Method 1: Try direct download with blob\n        const response = yield lastValueFrom(_this2.http.get(`${_this2.apiUrl}${downloadUrl}`, {\n          responseType: 'blob',\n          observe: 'response'\n        }));\n        if (response.body) {\n          const blob = new Blob([response.body], {\n            type: 'text/plain'\n          });\n          const url = window.URL.createObjectURL(blob);\n          const link = document.createElement('a');\n          link.href = url;\n          link.download = fileName;\n          link.style.display = 'none';\n          document.body.appendChild(link);\n          link.click();\n          document.body.removeChild(link);\n          // Clean up\n          window.URL.revokeObjectURL(url);\n          console.log('File downloaded successfully');\n        } else {\n          throw new Error('Empty response from server');\n        }\n      } catch (error) {\n        console.error('Download failed with HTTP method, trying direct link...', error);\n        // Method 2: Fallback to direct link\n        try {\n          const fullUrl = `${_this2.apiUrl}${downloadUrl}`;\n          const link = document.createElement('a');\n          link.href = fullUrl;\n          link.download = fileName;\n          link.target = '_blank';\n          link.rel = 'noopener noreferrer';\n          document.body.appendChild(link);\n          link.click();\n          document.body.removeChild(link);\n          console.log('Fallback download triggered');\n        } catch (fallbackError) {\n          console.error('Both download methods failed:', fallbackError);\n          throw new Error(`Download failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n        }\n      }\n    })();\n  }\n  testConnection() {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        yield lastValueFrom(_this3.http.get(`${_this3.apiUrl.replace('/api', '')}/api/test`));\n        return true;\n      } catch (error) {\n        console.error('Connection test failed:', error);\n        return false;\n      }\n    })();\n  }\n  listProcessedFiles() {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const response = yield lastValueFrom(_this4.http.get(`${_this4.apiUrl}/files/list`));\n        return response.files;\n      } catch (error) {\n        console.error('Error listing files:', error);\n        return [];\n      }\n    })();\n  }\n}\nFileProcessingService.ɵfac = function FileProcessingService_Factory(t) {\n  return new (t || FileProcessingService)(i0.ɵɵinject(i1.HttpClient));\n};\nFileProcessingService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: FileProcessingService,\n  factory: FileProcessingService.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"mappings":"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","names":["HttpErrorResponse","lastValueFrom","environment","FileProcessingService","constructor","http","apiUrl","processFiles","files","formData","FormData","i","length","append","response","post","error","console","status","Error","message","downloadFile","downloadUrl","fileName","log","get","responseType","observe","body","blob","Blob","type","url","window","URL","createObjectURL","link","document","createElement","href","download","style","display","appendChild","click","removeChild","revokeObjectURL","fullUrl","target","rel","fallbackError","testConnection","replace","listProcessedFiles","factory","providedIn"],"sourceRoot":"","sources":["/Users/jordandaake/Desktop/source/PHIRedactionApp/phi-redaction-app/src/app/services/file-processing.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport { HttpClient, HttpErrorResponse } from '@angular/common/http';\nimport { ProcessingResult } from '../models/processing-result.model';\nimport { lastValueFrom } from 'rxjs';\nimport { environment } from '../../environments/environment';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class FileProcessingService {\n  private readonly apiUrl = environment.apiUrl;\n\n  constructor(private http: HttpClient) { }\n\n  async processFiles(files: FileList): Promise<ProcessingResult> {\n    const formData = new FormData();\n    \n    for (let i = 0; i < files.length; i++) {\n      formData.append('files', files[i]);\n    }\n\n    try {\n      const response = await lastValueFrom(\n        this.http.post<ProcessingResult>(`${this.apiUrl}/files/process`, formData)\n      );\n      return response;\n    } catch (error) {\n      console.error('Error processing files:', error);\n      \n      if (error instanceof HttpErrorResponse) {\n        if (error.status === 0) {\n          throw new Error('Unable to connect to the server. Please ensure the API is running.');\n        } else if (error.status >= 400 && error.status < 500) {\n          throw new Error(error.error?.message || 'Invalid request. Please check your files and try again.');\n        } else if (error.status >= 500) {\n          throw new Error('Server error occurred. Please try again later.');\n        }\n      }\n      \n      throw new Error('An unexpected error occurred while processing files.');\n    }\n  }\n\n  async downloadFile(downloadUrl: string, fileName: string): Promise<void> {\n    try {\n      console.log('Downloading file:', downloadUrl);\n      \n      // Method 1: Try direct download with blob\n      const response = await lastValueFrom(\n        this.http.get(`${this.apiUrl}${downloadUrl}`, {\n          responseType: 'blob',\n          observe: 'response'\n        })\n      );\n\n      if (response.body) {\n        const blob = new Blob([response.body], { type: 'text/plain' });\n        const url = window.URL.createObjectURL(blob);\n        \n        const link = document.createElement('a');\n        link.href = url;\n        link.download = fileName;\n        link.style.display = 'none';\n        \n        document.body.appendChild(link);\n        link.click();\n        document.body.removeChild(link);\n        \n        // Clean up\n        window.URL.revokeObjectURL(url);\n        \n        console.log('File downloaded successfully');\n      } else {\n        throw new Error('Empty response from server');\n      }\n    } catch (error) {\n      console.error('Download failed with HTTP method, trying direct link...', error);\n      \n      // Method 2: Fallback to direct link\n      try {\n        const fullUrl = `${this.apiUrl}${downloadUrl}`;\n        const link = document.createElement('a');\n        link.href = fullUrl;\n        link.download = fileName;\n        link.target = '_blank';\n        link.rel = 'noopener noreferrer';\n        \n        document.body.appendChild(link);\n        link.click();\n        document.body.removeChild(link);\n        \n        console.log('Fallback download triggered');\n      } catch (fallbackError) {\n        console.error('Both download methods failed:', fallbackError);\n        throw new Error(`Download failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n      }\n    }\n  }\n\n  async testConnection(): Promise<boolean> {\n    try {\n      await lastValueFrom(\n        this.http.get(`${this.apiUrl.replace('/api', '')}/api/test`)\n      );\n      return true;\n    } catch (error) {\n      console.error('Connection test failed:', error);\n      return false;\n    }\n  }\n\n  async listProcessedFiles(): Promise<string[]> {\n    try {\n      const response = await lastValueFrom(\n        this.http.get<{files: string[]}>(`${this.apiUrl}/files/list`)\n      );\n      return response.files;\n    } catch (error) {\n      console.error('Error listing files:', error);\n      return [];\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}